<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode215_数组中的第K个最大元素</title>
    <url>/posts/a1ffbfe0/</url>
    <content><![CDATA[<p>题目描述：</p>
<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function findKthLargest(nums, k) &#123;</span><br><span class="line">    var N &#x3D; nums.length;</span><br><span class="line">    nums.sort((a,b)&#x3D;&gt;a-b);    &#x2F;&#x2F;从小到大排序，避免[1,10,2,...]的情况</span><br><span class="line">    return nums[N - k];    &#x2F;&#x2F;最大的是nums[N-1], 次大的是nums[N-2], ...</span><br><span class="line">&#125;</span><br><span class="line">console.log(findKthLargest([3,2,1,10,5,6,4], 2));    &#x2F;&#x2F;6</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度 : <strong>O(Nlogk)</strong> 。向大小为 k 的堆中添加元素的时间复杂度为 O(logk)，我们将重复该操作 N 次，故总时间复杂度为 O(Nlogk)。</p>
<p>空间复杂度 : <strong>O(k)</strong> ，用于存储堆元素。</p>
<h4 id="方法二：小顶堆"><a href="#方法二：小顶堆" class="headerlink" title="方法二：小顶堆"></a>方法二：小顶堆</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.PriorityQueue;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums1 &#x3D; &#123;3,2,1,5,6,4&#125;;</span><br><span class="line">        System.out.println(findKthLargest(nums1, 2));    &#x2F;&#x2F;5</span><br><span class="line">        int[] nums2 &#x3D; &#123;3,2,3,1,2,4,5,5,6&#125;;</span><br><span class="line">        System.out.println(findKthLargest(nums2, 4));    &#x2F;&#x2F;4</span><br><span class="line">    &#125;</span><br><span class="line">    public static int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        &#x2F;&#x2F; init heap &#39;the smallest element first&#39;    小顶堆</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap &#x3D; new PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        for (int n: nums) &#123;</span><br><span class="line">            heap.add(n);    &#x2F;&#x2F; 添加</span><br><span class="line">            if (heap.size() &gt; k)&#123;    &#x2F;&#x2F; keep k largest elements in the heap</span><br><span class="line">                heap.poll();    &#x2F;&#x2F; 从小顶堆的堆顶删除</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return heap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度 : 平均情况 <strong>O(N)</strong> ，最坏情况 <strong>O($N^2$)</strong> 。</p>
<p>空间复杂度 : <strong>O(1)</strong> 。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode347_前K个高频元素</title>
    <url>/posts/5dbffad1/</url>
    <content><![CDATA[<p>题目描述：</p>
<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>说明：你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 $O(n log n)$, n 是数组的大小。</p>
<h4 id="解法一：小顶堆"><a href="#解法一：小顶堆" class="headerlink" title="解法一：小顶堆"></a>解法一：小顶堆</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        int[] nums1 = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        int k = <span class="number">2</span>;</span><br><span class="line">        System.out.println(solution.topKFrequent(nums1, k));    <span class="comment">//[1, 2]</span></span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Integer&gt; <span class="function"><span class="title">topKFrequent</span>(<span class="params">int[] nums, int k</span>)</span> &#123;    <span class="comment">//返回值是一个列表List</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (int n: nums) &#123;</span><br><span class="line">            count.put(n, count.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);    <span class="comment">// count.getOrDefault(n, 0)+1) </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// init heap &#x27;the less frequent element first&#x27; 小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; count.get(n1) - count.get(n2));</span><br><span class="line">        <span class="comment">// keep k top frequent elements in the heap</span></span><br><span class="line">        <span class="keyword">for</span> (int n: count.keySet()) &#123;	<span class="comment">//key的集合</span></span><br><span class="line">            heap.add(n);    <span class="comment">//这里的add是根据key对应的值大小去插入的，最终得到小顶堆</span></span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; top_k = <span class="keyword">new</span> LinkedList();    <span class="comment">//LinkedList底层是通过双向链表实现的</span></span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            top_k.add(heap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(top_k);</span><br><span class="line">        <span class="keyword">return</span> top_k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p><strong>时间复杂度：$O(Nlogk)$。</strong>遍历一遍数组统计元素的频率的时间复杂度是 O(N)，建堆和输出的复杂度是 O(Nlog(k))。因此总复杂度为 O(N+Nlog(k))=O(Nlog(k))。</p>
<p><strong>空间复杂度：$O(N)$，</strong>存储哈希表的开销。最坏情况下（每个元素都不同），map 需要存储 n 个键值对，优先队列需要存储 k 个元素，因此，空间复杂度是 O(n)。根据复杂度分析，方法对于小 k 的情况是很优的。但是如果 k 值很大，我们可以将算法改成删除频率最低的若干个元素。</p>
<h4 id="解法二：桶排序法"><a href="#解法二：桶排序法" class="headerlink" title="解法二：桶排序法"></a>解法二：桶排序法</h4><p>首先依旧使用哈希表统计频率，统计完成后，创建一个数组，将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Solution solution &#x3D; new Solution();</span><br><span class="line">        int[] nums1 &#x3D; &#123;1,1,1,2,2,3&#125;;</span><br><span class="line">        int k &#x3D; 2;</span><br><span class="line">        System.out.println(solution.topKFrequent(nums1, k));    &#x2F;&#x2F;[1, 2]</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList();    &#x2F;&#x2F;返回值res是一个数组，其长度等于k</span><br><span class="line">        &#x2F;&#x2F; 使用哈希表（字典），统计每个元素出现的次数，元素为键，元素出现的次数为值</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map &#x3D; new HashMap();</span><br><span class="line">        for(int num : nums)&#123;</span><br><span class="line">            if (map.containsKey(num)) &#123;</span><br><span class="line">                map.put(num, map.get(num) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                map.put(num, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;桶排序：获取出现的次数作为下标</span><br><span class="line">        &#x2F;&#x2F;将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标</span><br><span class="line">        List&lt;Integer&gt;[] list &#x3D; new List[nums.length+1];    &#x2F;&#x2F;list最大的长度是当输入的所有数字都一样时的长度加1</span><br><span class="line">        for(int key : map.keySet())&#123;</span><br><span class="line">            int i &#x3D; map.get(key);    &#x2F;&#x2F; 获取出现的次数作为下标</span><br><span class="line">            if(list[i] &#x3D;&#x3D; null)&#123;</span><br><span class="line">               list[i] &#x3D; new ArrayList();  &#x2F;&#x2F;这里是一个数组,因为可能有多个数字出现的次数是一样的</span><br><span class="line">            &#125;</span><br><span class="line">            list[i].add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 倒序遍历数组获取出现顺序从大到小的排列</span><br><span class="line">        for(int i &#x3D; list.length - 1;i &gt;&#x3D; 0 &amp;&amp; res.size() &lt; k;i--)&#123;    &#x2F;&#x2F;返回值res是一个数组，其长度等于k</span><br><span class="line">            if(list[i] &#x3D;&#x3D; null) continue;</span><br><span class="line">            res.addAll(list[i]);    &#x2F;&#x2F;存入的是一个数组，所以用addAll()而非add()</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p><strong>时间复杂度：O(n)</strong> ，n 表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；桶的数量为 n+1，所以桶排序的时间复杂度为 O(n)；因此，总的时间复杂度是 O(n)。</p>
<p><strong>空间复杂度：O(n)</strong> 。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Netease Autoplay</title>
    <url>/posts/bd922f6f/</url>
    <content><![CDATA[<h1 id="Ballade-Pour-Adeline"><a href="#Ballade-Pour-Adeline" class="headerlink" title="Ballade Pour Adeline"></a>Ballade Pour Adeline</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=34341358&auto=0&height=66"></iframe>

]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode233</title>
    <url>/posts/778b2935/</url>
    <content><![CDATA[<p>题目描述：</p>
<p>哈哈哈</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>

]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode11</title>
    <url>/posts/4650e1fb/</url>
    <content><![CDATA[<p>题目描述：</p>
<p>今天是个好日子</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>

]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Spider_BaiduTieba_Pics</title>
    <url>/posts/e3e57d4d/</url>
    <content><![CDATA[<p><strong>描述：</strong></p>
<p>利用python3.x爬虫下载贴吧内图片</p>
<a id="more"></a>

<p><strong>使用方法：</strong></p>
<p>在当前目录下，运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python baidutieba.py</span><br></pre></td></tr></table></figure>
<p>可以看到pic文件夹中下载好了图片…</p>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># baidutieba.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断路径是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    isExists=os.path.exists(path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">        <span class="comment"># 如果不存在则创建目录</span></span><br><span class="line">path = <span class="string">&#x27;./pic&#x27;</span></span><br><span class="line">mkdir(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># html代码</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHtml</span>(<span class="params">url</span>):</span></span><br><span class="line">    page = urllib.request.urlopen(url)</span><br><span class="line">    html = page.read()</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line">html = getHtml(<span class="string">&quot;http://tieba.baidu.com/p/3205263090&quot;</span>)</span><br><span class="line">html = html.decode(<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># imgList</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImg</span>(<span class="params">html</span>):</span></span><br><span class="line">    reg = <span class="string">r&#x27;src=&quot;([.*\S]*\.jpg)&quot; pic_ext=&quot;jpeg&quot;&#x27;</span></span><br><span class="line">    imgre = re.<span class="built_in">compile</span>(reg);</span><br><span class="line">    imglist = re.findall(imgre, html)</span><br><span class="line">    <span class="keyword">return</span> imglist</span><br><span class="line">imgList = getImg(html)</span><br><span class="line"><span class="comment"># imgList: img地址数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># imgPath, for循环</span></span><br><span class="line">imgName = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> imgPath <span class="keyword">in</span> imgList:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;pic/&quot;</span>+<span class="built_in">str</span>(imgName)+<span class="string">&quot;.jpg&quot;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    f.write((urllib.request.urlopen(imgPath)).read())</span><br><span class="line">    f.close()</span><br><span class="line">    imgName += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 只复制10张照片</span></span><br><span class="line">    <span class="keyword">if</span> imgName==<span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(<span class="string">&quot;All Done!&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>大整数乘法</title>
    <url>/posts/5de969be/</url>
    <content><![CDATA[<p>链接：<br><a href="https://www.codewars.com/kata/55911ef14065454c75000062/solutions/javascript">Multiplying numbers as strings | Codewars</a></p>
<a id="more"></a>

<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function multiply(a,b)&#123;</span><br><span class="line">    var str1,str2,len1,len2,maxlen,result &#x3D; [];</span><br><span class="line">    str1 &#x3D; a.split(&quot;&quot;).reverse();</span><br><span class="line">    str2 &#x3D; b.split(&quot;&quot;).reverse();</span><br><span class="line">    len1 &#x3D; str1.length;</span><br><span class="line">    len2 &#x3D; str2.length;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造长度为 len1+len2（i+j从0到len1+len2-1）、数组元素都为0的数组result</span><br><span class="line">    &#x2F;&#x2F; 因为要在下一步做累加，如果不初始化为0，result[]中的值会变为NaN，因为未初始化的数组中的值为undefined</span><br><span class="line">    let len&#x3D;len1+len2</span><br><span class="line">    for(let i&#x3D;0; i&lt;len; i++)&#123;</span><br><span class="line">        result[i]&#x3D;0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 乘法的计算过程</span><br><span class="line">    for(var i &#x3D; 0; i &lt; len1; i++)&#123;</span><br><span class="line">        for(var j &#x3D; 0; j &lt; len2; j++)&#123;</span><br><span class="line">            &#x2F;&#x2F;根据乘法的手动计算方式，在上下相同位上会有相加</span><br><span class="line">            result[i+j] +&#x3D; parseInt(str1[i]) * parseInt(str2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 结果的每一位与10进行判断</span><br><span class="line">    var n &#x3D; result.length;</span><br><span class="line">    for(var k &#x3D; 0; k &lt; n; k++)&#123;</span><br><span class="line">        var temp &#x3D; result[k];</span><br><span class="line">        if(temp &gt;&#x3D; 10)&#123;</span><br><span class="line">            &#x2F;&#x2F; 大于10则取余数，并进一位</span><br><span class="line">            result[k] &#x3D; temp % 10;</span><br><span class="line">            result[k+1] +&#x3D;  Math.floor(temp &#x2F; 10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 排除result为[0], [0,0,0]的情况</span><br><span class="line">    let res &#x3D; result.reverse().join(&quot;&quot;)</span><br><span class="line">    return res&#x3D;&#x3D;0 ? 0 : res.replace(&#x2F;\b(0*)&#x2F;gi,&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">var d &#x3D; multiply(&quot;900719925474099122&quot;, &quot;9007199254740991111222&quot;);</span><br><span class="line">console.log(d);</span><br><span class="line">&#x2F;&#x2F; len1 &#x3D; 18</span><br><span class="line">&#x2F;&#x2F; len2 &#x3D; 22</span><br><span class="line">&#x2F;&#x2F; result.length &#x3D; 40</span><br><span class="line">&#x2F;&#x2F; 8112963841460666666477304721590154547084</span><br><span class="line">&#x2F;&#x2F; console.log(d.length); &#x2F;&#x2F;40</span><br><span class="line"></span><br><span class="line">let aa1 &#x3D; multiply(&quot;98765&quot;, &quot;56894&quot;)</span><br><span class="line">console.log(aa1)</span><br><span class="line">&#x2F;&#x2F; 5619135910</span><br><span class="line">let aa2 &#x3D; multiply(&quot;0000001&quot;, &quot;3&quot;)</span><br><span class="line">console.log(aa2)</span><br><span class="line">&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title>数组移动所有的0到末尾</title>
    <url>/posts/829d94d0/</url>
    <content><![CDATA[<p>链接：<a href="https://www.codewars.com/kata/52597aa56021e91c93000cb0/">Moving Zeros To The End | Codewars</a></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">moveZeros([false,1,0,1,2,0,1,3,&quot;a&quot;]) </span><br><span class="line">&#x2F;&#x2F; returns[false,1,1,2,1,3,&quot;a&quot;,0,0]</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function moveZeros(arr)&#123;</span><br><span class="line">    let arrA&#x3D;[]</span><br><span class="line">    let arrB&#x3D;[]</span><br><span class="line">    arr.forEach(function(value, index)&#123;</span><br><span class="line">        if(value&#x3D;&#x3D;&#x3D;0)&#123;</span><br><span class="line">            arrB.push(0)</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            arrA.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    let newArr &#x3D; arrA.concat(arrB)</span><br><span class="line">    return newArr</span><br><span class="line">&#125;</span><br><span class="line">console.log(moveZeros([&quot;a&quot;,0,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,1,1,3,1,9,0,0,9,0,0,0,0,0,0,0]))</span><br><span class="line">其他人的例子：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用concat连接两次筛选得到的数组</span><br><span class="line">var moveZeros &#x3D; function (arr) &#123;</span><br><span class="line">  return arr.filter(function(x) &#123;return x !&#x3D;&#x3D; 0&#125;).concat(arr.filter(function(x) &#123;return x &#x3D;&#x3D;&#x3D; 0;&#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用concat连接两次筛选得到的数组</span><br><span class="line">var moveZeros &#x3D; function (arr) &#123;</span><br><span class="line">  var filtedList &#x3D; arr.filter(function (num)&#123;return num !&#x3D;&#x3D; 0;&#125;);</span><br><span class="line">  var zeroList &#x3D; arr.filter(function (num)&#123;return num &#x3D;&#x3D;&#x3D; 0;&#125;);</span><br><span class="line">  return filtedList.concat(zeroList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用concat连接两次筛选得到的数组</span><br><span class="line">var moveZeros &#x3D; function (arr) &#123;</span><br><span class="line">  return arr</span><br><span class="line">    .filter((val) &#x3D;&gt; val !&#x3D;&#x3D; 0)</span><br><span class="line">    .concat(arr.filter((val) &#x3D;&gt; val &#x3D;&#x3D;&#x3D; 0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从数组的最后一个元素开始判断，这样就不会出错。不要从头开始。</span><br><span class="line">var moveZeros &#x3D; function (arr) &#123;</span><br><span class="line">  for(var i &#x3D; arr.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    if(arr[i] &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      arr.splice(i, 1);</span><br><span class="line">      arr.push(0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6的剩余参数 ...</span><br><span class="line">&#x2F;&#x2F; ... 可以把数组变为字符串</span><br><span class="line">var moveZeros &#x3D; function (arr) &#123;</span><br><span class="line">  return [</span><br><span class="line">    ...(arr.filter(n &#x3D;&gt; n !&#x3D;&#x3D; 0)),</span><br><span class="line">    ...(arr.filter(n &#x3D;&gt; n &#x3D;&#x3D;&#x3D; 0))</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 要先reverse()</span><br><span class="line">var moveZeros &#x3D; function (arr) &#123;</span><br><span class="line">  return arr.reverse().reduce(function(ret,v)&#123;</span><br><span class="line">    return v &#x3D;&#x3D;&#x3D; 0 ? ret.push(v) : ret.unshift(v), ret;</span><br><span class="line">  &#125;,[]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title>计算阶乘 N! 末尾0的数量</title>
    <url>/posts/5e6c4a65/</url>
    <content><![CDATA[<p>链接：<a href="https://www.codewars.com/kata/52f787eb172a8b4ae1000a34/solutions/javascript">Number of trailing zeros of N! | Codewars</a></p>
<a id="more"></a>

<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;关键在于计算5的个数</span><br><span class="line">function zeros(n) &#123;</span><br><span class="line">    let count&#x3D;0;</span><br><span class="line">    let temp&#x3D;parseInt(n&#x2F;5);</span><br><span class="line">    while(temp!&#x3D;&#x3D;0)&#123;</span><br><span class="line">        count+&#x3D;temp;</span><br><span class="line">        temp&#x3D;parseInt(temp&#x2F;5);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">console.log(zeros(25));</span><br><span class="line">&#x2F;&#x2F; 6</span><br><span class="line">console.log(zeros(101));</span><br><span class="line">&#x2F;&#x2F; 24</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>两个正整数相乘，乘积的尾部含有<code>0</code>的情况如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1个0：2*5&#x3D;10，可以写成2^1*5^1&#x3D;10^1</span><br><span class="line">2个0：4*25&#x3D;100，可以写成2^2*5^2&#x3D;10^2</span><br><span class="line">3个0：8*125&#x3D;1000，可以写成2^3*5^3&#x3D;10^3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>计算尾部<code>0</code>的数量，等价于计算两个乘数中含有的质因数<code>2</code>和<code>5</code>的数量。</p>
<p>回到阶乘<code>N!</code>的计算上，计算尾部0的数量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5! &#x3D; 5*4*3*2*1 &#x3D; 120，尾部有1个0，因为只有1个质因数5和3个质因数2；</span><br><span class="line">25! &#x3D; 15511210043330985984000000，尾部有6个0，因为含有6个质因数5；</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串加密</title>
    <url>/posts/bcc83ebd/</url>
    <content><![CDATA[<p>链接：<a href="https://www.codewars.com/kata/encrypt-this">字符串加密 Encrypt this!</a></p>
<h3 id="Rules"><a href="#Rules" class="headerlink" title="Rules:"></a>Rules:</h3><ul>
<li>The first letter needs to be converted to its ASCII code.</li>
<li>The second letter needs to be switched with the last letter</li>
</ul>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h3><p>encryptThis(“Hello”) === “72olle”<br>encryptThis(“good”) === “103doo”<br>encryptThis(“hello world”) === “104olle 119drlo”</p>
<a id="more"></a>

<p>加密字符串：字符串的第一个字母转为ASCII码，第二个字母与最后一个字母交换。</p>
<p>解法1：利用<code>Array.prototype.slice</code>截取字符串的字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var encryptThis &#x3D; function(text) &#123;</span><br><span class="line">    let arr &#x3D; text.split(&#39; &#39;).map(function(item)&#123;</span><br><span class="line">        if(item.length&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return item.charCodeAt(0)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(item.length&#x3D;&#x3D;2)&#123;</span><br><span class="line">            return item.charCodeAt(0)+item.slice(1)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(item.length&gt;&#x3D;3)&#123;</span><br><span class="line">            return item.charCodeAt(0)+item.slice(-1)+item.slice(2,-1)+item[1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return arr.join(&quot; &quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法2：利用正则表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const encryptThis &#x3D; text &#x3D;&gt; text</span><br><span class="line">  .split(&#39; &#39;)</span><br><span class="line">  .map(word &#x3D;&gt; word</span><br><span class="line">      .replace(&#x2F;(^\w)(\w)(\w*)(\w$)&#x2F;, &#96;$1$4$3$2&#96;)</span><br><span class="line">      .replace(&#x2F;^\w&#x2F;, word.charCodeAt(0))</span><br><span class="line">  )</span><br><span class="line">  .join(&#39; &#39;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title>2016年中山大学无机化学考研经验分享</title>
    <url>/posts/7850ff03/</url>
    <content><![CDATA[<p><strong>关注小木虫论坛挺久了，也从中受益匪浅！</strong><br><strong>最近有师弟师妹问到考研经验，所以来这里分享点考研复习经验，给有需要的师弟师妹~</strong></p>
<a id="more"></a>

<blockquote>
<p>我考的是本校的无机化学专业。初试成绩是政治71，英语76，专业课较为一般，一些考题答得感觉不是很好。<br>后来进了复试，后来又顺利通过了复试、顺利录取。<br>…<br>…</p>
<p>我是大三时决定考研，暑假之前还要上课，主要是上课之外花一些时间复习，暑假开始系统地复习，也就是还剩下大约半年时间。复习的时间比较仓促，然而要复习的内容挺多！</p>
<p>化学学院几个专业的初试试题都是一样的，包含无机、有机(包含波谱)、分析(包含仪分)、物化、结构化学这5门课程，所以复习的内容是很多的，就要规划好，并有一定的侧重点。</p>
<p>考研的化学A、化学B、政治和英语每一门课都很重要! 像今年化学复试总分要355分以上才能进复试，所以你哪一门考砸了就基本没戏……<br>…<br>复习的话，第一遍复习是对所有知识点都复习到，对于课本内容有个大概的了解，也就是看到题目能知道考的是什么、怎么去解答。<br>第二遍、第三遍可以针对性地复习不熟悉的知识点，做题、回过去看书等。同时复习时可以结合辅导书籍、真题、练习题等来复习。</p>
</blockquote>
<h1 id="本文重点："><a href="#本文重点：" class="headerlink" title="本文重点："></a>本文重点：</h1><blockquote>
<p><strong>找到适合自己的复习方法。</strong></p>
<p><strong>要学会归纳总结。</strong></p>
<p><strong>复习要有一定的侧重点。</strong></p>
<p><strong>往年真题很重要！往年真题很重要！往年真题很重要！</strong></p>
</blockquote>
<h1 id="复习经验："><a href="#复习经验：" class="headerlink" title="复习经验："></a>复习经验：</h1><h2 id="一、专业课"><a href="#一、专业课" class="headerlink" title="一、专业课"></a>一、专业课</h2><blockquote>
<p><strong>1、复习要有一定的侧重点。</strong><br>我觉得物化、分析、有机 知识点多，内容比较难 2333…… 所以在这几科上都花了很多时间去理解、做题，尽量做到知识点比较熟悉，选择题不丢分。<br><strong>2、复习时自己进行归纳总结。</strong><br>可以找一张空白的A4纸或一个本子，自己归纳下考点，在复习时有很大帮助。<br><strong>3、做题时多回去翻书看知识点。</strong><br>遇到知识点模糊时，及时去翻书很重要，不要留下太多的知识盲点。</p>
</blockquote>
<h2 id="二、公共课"><a href="#二、公共课" class="headerlink" title="二、公共课"></a>二、公共课</h2><blockquote>
<p><strong>1、考研政治</strong><br>政治可以说分两部分，选择题和简答题(主观题)。在时间不充足的情况下，怎么高效地复习是关键。<br>推荐肖秀荣的《考研政治 命题人讲真题》、《命题人1000题》，课本倒不用去看了，一是时间不够，二是精力有限，没法根据课本内容归纳总结，所以买现成的辅导书就好了。还有《文都考研 考研思想政治理论主观题应试宝典》，对于近几年的考题都有了归纳和知识点分析。<br>复习前期可以每天抽点时间背背知识点、看看真题，分析答题的规律。主观题，不外乎马原、毛中特、近现代史、思修、时政五个方面。答题不是答得越多越好，而是要答到知识点！要答到知识点！要答到知识点！重要的事情说三遍。<br>复习后期再刷刷题。刷不完1000题也没多大关系，重要的是对于知识点要熟悉，再次碰到时不能丢分！</p>
</blockquote>
<blockquote>
<p><strong>2、考研英语</strong><br><strong>基础很重要！基础很重要！基础很重要！重要的事情说三遍。</strong><br>所谓基础，不是说你要四级或六级要考多少分才算基础好。这里的“基础”指的是对于基础知识的掌握和熟练程度，包括单词、词汇、语法等。复习不外乎背单词、做练习、练作文，以及做往年真题。<br><strong>往年真题很重要！</strong><br>最好把最近几年的考题都做一遍，然后对照答案和解析看一下！</p>
<p>背单词可以借助扇贝APP或其他APP(之前没用APP背单词)，或者考研词汇书、四六级词汇书、考研词汇5500词等都可以。<br>比如做完形填空的时候，如果词汇量积累不够、语法基础不好，在考场上那就真是“鸡同鸭讲眼碌碌”…… 看着单词都不清楚什么意思，那还选得到正确答案？我翻了下以前的复习记录，完形填空试过20道错了8道的，阅读理解5道选择题错了3、4个的也有，应该是因为太久没做题了，加之基础不是很牢固。到后来情况就好许多了。</p>
<p>…</p>
</blockquote>
<h2 id="三、几个问题："><a href="#三、几个问题：" class="headerlink" title="三、几个问题："></a>三、几个问题：</h2><p><strong>1、时间安排？</strong></p>
<blockquote>
<p>时间安排上，尽量每天都能坚持复习。可以做到早上8点到12点，下午2点到6点，晚上7点到11点最好 23333…… 我是没做到……</p>
<p>不是说每天都要高强度复习，你规划好这个月要复习哪些内容、做完哪些练习，那么每天花足够的时间就可以了，能一直坚持下去才重要。我在复习时看到有同学宣告退出了，也觉得能理解，毕竟每个人都有适合自己的道路，不一定非要考研。</p>
</blockquote>
<p><strong>2、考研现在复习晚吗？</strong></p>
<blockquote>
<p>不晚。如果说晚了，那你是不考了吗？<br>当然，假设复习总时间是一定的，如果你复习已经很晚了，那么你每天就需要花很多的时间去准备……</p>
</blockquote>
<p><strong>3、需要报班吗？</strong></p>
<blockquote>
<p>因人而异。我复习的时候没报班，感觉自己花些时间整理知识点、花些时间去复习足够了。</p>
</blockquote>
<p><strong>4、……</strong></p>
<blockquote>
<p>……</p>
</blockquote>
<p><strong>最后，祝大家都考上理想的大学！</strong></p>
]]></content>
      <categories>
        <category>Chemistry</category>
      </categories>
      <tags>
        <tag>Chemistry</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreeJS Learning</title>
    <url>/posts/622ca411/</url>
    <content><![CDATA[<p><strong>Three.js是一个3D JavaScript库。</strong></p>
<p><strong>Three.js封装了底层的图形接口，使得程序员能够在无需掌握繁冗的图形学知识的情况下，也能用简单的代码实现三维场景的渲染。</strong></p>
<a id="more"></a>

<pre><code>优点：
使用Three.js开发要比WebGL更快更高效。
对于不熟悉图形学知识的程序员而言，使用Three.js能够降低学习成本，提高三维图形程序开发的效率。</code></pre>
<h1 id="一、WebGL"><a href="#一、WebGL" class="headerlink" title="一、WebGL"></a>一、WebGL</h1><blockquote>
<p>WebGL是基于OpenGL ES 2.0 的Web标准，可以通过 HTML5 Canvas元素作为 DOM接口访问。<br>WebGL可以看做是将 OpenGL ES（OpenGL for Embedded Systems，OpenGL嵌入式版本，针对手机、游戏机等设备相对较轻量级的版本）移植到了网页平台，像Chrome、Firefox 这些现代浏览器都实现了WebGL标准，使用JavaScript就可以用你熟悉的、类似OpenGL的代码编写了。</p>
<p>你可以把 WebGL简单地认为是一种网络标准，定义了一些较底层的图形接口，至于究竟多底层，稍后我们和Three.js代码对比来看。<br>现在，我们知道了WebGL是一个底层的标准，在这些标准被定义之后，Chrome、Firefox之类的浏览器实现了这些标准。然后，程序员就能通过JavaScript代码，在网页上实现三维图形的渲染了。</p>
</blockquote>
<h1 id="二、ThreeJS程序"><a href="#二、ThreeJS程序" class="headerlink" title="二、ThreeJS程序"></a>二、ThreeJS程序</h1><blockquote>
<p>一个典型的Three.js程序至少要包括：<br>渲染器（Renderer）、场景（Scene）、照相机（Camera），以及你在场景中创建的物体。</p>
</blockquote>
<h2 id="渲染器（Render）"><a href="#渲染器（Render）" class="headerlink" title="渲染器（Render）"></a>渲染器（Render）</h2><p>WebGL的渲染是需要 <strong>HTML5 Canvas元素</strong> 的，可以手动在HTML的 <body> 部分中定义 Canvas元素，或者用Three.js生成。</p>
<p>手动在 HTML中定义：</p>
<pre><code>&lt;body onload=&quot;init()&quot;&gt;
   &lt;canvas id=&quot;mainCanvas&quot; width=&quot;400px&quot; height=&quot;300px&quot; &gt;&lt;/canvas&gt;
&lt;/body&gt;</code></pre>
<p>用Three.js生成 Canvas元素：</p>
<pre><code>var renderer = new THREE.WebGLRenderer();
renderer.setSize(400, 300);
document.getElementsByTagName(&#39;body&#39;)[0].appendChild(renderer.domElement);</code></pre>
<p>上面代码的第二行表示设置 Canvas的宽 400 像素，高 300 像素。第三行将渲染器对应的Canvas元素添加到<body>中。<br>我们可以使用下面的代码将背景色（用于清除画面的颜色）设置为黑色：</p>
<pre><code>renderer.setClearColor(0x000000);</code></pre>
<h2 id="场景（Scene）"><a href="#场景（Scene）" class="headerlink" title="场景（Scene）"></a>场景（Scene）</h2><p>在Three.js中添加的物体都是添加到场景中的，因此它相当于一个大容器。一般说，场景<br>来没有很复杂的操作，在程序最开始的时候进行实例化，然后将物体添加到场景中即可。</p>
<pre><code>var scene = new THREE.Scene();</code></pre>
<h2 id="照相机（Camera）"><a href="#照相机（Camera）" class="headerlink" title="照相机（Camera）"></a>照相机（Camera）</h2><p>在介绍照相机设置前，我们先来简单了解下坐标系。WebGL和 Three.js使用的坐标系是右手坐标系。<br>这里，我们定义了一直透视投影的照相机，具体原理将在下一章中展开。</p>
<pre><code>var camera = new THREE.PerspectiveCamera(45, 4 / 3, 1, 1000);
camera.position.set(0, 0, 5);
scene.add(camera);</code></pre>
<p>值得注意的是，照相机也需要被添加到场景中。</p>
<blockquote>
<p>我们使用Three.js创建的场景是三维的，而通常情况下显示屏是二维的，那么三维的场景如何显示到二维的显示屏上呢？<br>照相机就是这样一个抽象，它定义了三维空间到二维屏幕的投影方式，用“照相机”这样一个类比，可以使我们直观地理解这一投影方式。</p>
</blockquote>
<p><strong>针对投影方式的不同，照相机又分为正交投影照相机与透视投影照相机。</strong></p>
<p>一般说来，对于制图、建模软件通常使用正交投影，这样不会因为投影而改变物体比例；而对于其他大多数应用，通常使用透视投影，因为这更接近人眼的观察效果。当然，照相机的选择并没有对错之分，你可以更具应用的特性，选择一个效果更佳的照相机。</p>
<p><strong>1、正交投影照相机（Orthographic Camera）</strong></p>
<p>设置起来较为直观，它的构造函数是：</p>
<pre><code>THREE.OrthographicCamera(left, right, top, bottom, near, far)</code></pre>
<p>这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置，这两个面围成一个长方体，我们称其为视景体（Frustum）。只有在视景体内部（下图中的灰色部分）的物体才可能显示在屏幕上，而视景体外的物体会在显示之前被裁减掉。<br>设置照相机：</p>
<pre><code>var camera = new THREE.OrthographicCamera(-2, 2, 1.5, -1.5, 1, 10);
camera.position.set(0, 0, 5);
scene.add(camera);</code></pre>
<p>在原点处创建一个边长为1的正方体，为了和透视效果做对比，这里我们使用wireframe而不是实心的材质，以便看到正方体后方的边：</p>
<pre><code>var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),
    new THREE.MeshBasicMaterial(&#123;
        color: 0xff0000,
        wireframe: true
    &#125;) 
);
scene.add(cube);</code></pre>
<p>现在，如果我们将照相机向右移动 1 个单位：</p>
<pre><code>var camera = new THREE.OrthographicCamera(-2, 2, 1.5, -1.5, 1, 10);
camera.position.set(1, 0, 5);</code></pre>
<p>得到的效果是物体看上去向左移动了 。。。</p>
<p><strong>换个角度看世界</strong></p>
<p>到现在为止，我们使用照相机都是沿z轴负方向观察的，因此看到的都是一个正方形。现在，我们想尝试一下仰望这个正方体。我们已经学会设置照相机的位置，不妨将其设置在(4, -3, 5)处：</p>
<pre><code>camera.position.set(4, -3, 5);</code></pre>
<p>但是现在照相机沿z轴负方向观察的，因此观察不到正方体，只看到一片黑。我们可以通过 lookAt 函数指定它看着原点方向：</p>
<pre><code>camera.lookAt(new THREE.Vector3(0, 0, 0));</code></pre>
<p>这样我们就能过仰望正方体啦。</p>
<p><strong>2、透视投影照相机（Perspective Camera）</strong></p>
<p>构造函数是：</p>
<pre><code>THREE.PerspectiveCamera(fov, aspect, near, far)</code></pre>
<p>fov 是视景体竖直方向上的张角（是角度制而非弧度制）</p>
<p>aspect 等于 width / height，是照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例。</p>
<p>near 和 far 分别是照相机到视景体最近、最远的距离，均为正值，且 far 应大于near。</p>
<p>设置透视投影照相机，这里 Canvas长 400px，宽 300px，所以 aspect设为 400 / 300：</p>
<pre><code>var camera = new THREE.PerspectiveCamera(45, 400 / 300, 1, 10);
camera.position.set(0, 0, 5);
scene.add(camera);</code></pre>
<p>和例2.3.1一样，设置一个在原点处的边长为 1的正方体：</p>
<pre><code>// a cube in the scene
var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),
    new THREE.MeshBasicMaterial(&#123;
        color: 0xff0000,
        wireframe: true
    &#125;)
);
scene.add(cube);</code></pre>
<h2 id="长方体"><a href="#长方体" class="headerlink" title="长方体"></a>长方体</h2><p>我们要创建一个x、y、z方向长度分别为 1、2、 3 的长方体，并将其设置为红色。</p>
<pre><code>var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 2, 3),
    new THREE.MeshBasicMaterial(&#123;
        color: 0xff0000
    &#125;)
);
scene.add(cube);</code></pre>
<h2 id="立方体（CubeGeometry）"><a href="#立方体（CubeGeometry）" class="headerlink" title="立方体（CubeGeometry）"></a>立方体（CubeGeometry）</h2><p>虽然这一形状的名字叫立方体（CubeGeometry），但它其实是长方体，也就是长宽高可以设置为不同的值。其构造函数是：</p>
<pre><code>THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)</code></pre>
<p>这里，width 是x方向上的长度； height 是 y方向上的长度； depth 是z方向上的长度；后三个参数分别是在三个方向上的分段数，如 widthSegments 为 3 的话，代表 x方向上水平分为三份。一般情况下不需要分段的话，可以不设置后三个参数，后三个参数的缺省值为 1。其他几何形状中的分段也是类似的，下面不做说明。<br>长宽高</p>
<p>创建立方体直观简单，如： </p>
<pre><code>new THREE.CubeGeometry(1, 2, 3); </code></pre>
<p>可以创建一个x方向长度为 1，y方向长度为 2，z方向长度为 3 的立方体。<br>物体的默认位置是原点，对于立方体而言，是其几何中心在原点的位置。</p>
<p><strong>分段</strong></p>
<p>而在设置了分段 </p>
<pre><code>new THREE.CubeGeometry(1, 2, 3, 2, 2, 3)</code></pre>
<p>注意这个分段是对六个面进行分段，而不是对立方体的体素分段，因此在立方体的中间是不分段的，只有六个侧面被分段。</p>
<p><strong>平面</strong><br>这里的平面（PlaneGeometry）其实是一个长方形，而不是数学意义上无限大小的平面。其构造函数为：</p>
<pre><code>THREE.PlaneGeometry(width, height, widthSegments, heightSegments)</code></pre>
<p>其中，width 是x方向上的长度； height 是 y方向上的长度；后两个参数同样表示分段。</p>
<pre><code>new THREE.PlaneGeometry(2, 4);</code></pre>
<p>创建的平面在x轴和y轴所在平面内</p>
<p><strong>球体</strong><br>球体（SphereGeometry）的构造函数是：</p>
<pre><code>THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, the taStart, thetaLength)</code></pre>
<p>其中，radius 是半径； segmentsWidth 表示经度上的切片数； segmentsHeight 表示纬度上的切片数；phiStart 表示经度开始的弧度；phiLength 表示经度跨过的弧度；<br>thetaStart 表示纬度开始的弧度； thetaLength 表示纬度跨过的弧度。</p>
<p><strong>圆形</strong><br>圆形（CircleGeometry）可以创建圆形或者扇形，其构造函数是： </p>
<pre><code>THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)</code></pre>
<p>这四个参数都是球体中介绍过的，这里不再赘述，直接来看个例子。</p>
<pre><code>new THREE.CircleGeometry(3, 18, Math.PI / 3, Math.PI / 3 * 4)</code></pre>
<p>可以创建一个在x轴和y轴所在平面的三分之二圆的扇形</p>
<h2 id="文字形状"><a href="#文字形状" class="headerlink" title="文字形状"></a>文字形状</h2><p>文字形状（TextGeometry）可以用来创建三维的文字形状。<br>略……</p>
<h1 id="实例剖析"><a href="#实例剖析" class="headerlink" title="实例剖析"></a>实例剖析</h1><h2 id="实例1："><a href="#实例1：" class="headerlink" title="实例1："></a>实例1：</h2><p>预览图：</p>
<p><img src="http://wx1.sinaimg.cn/mw690/e42e0766gy1fddmkvvi2mj20b408c0sk.jpg"></p>
<p>代码分析：</p>
<pre><code>在页面中对应设置id为mainCanvas的canvas标签，设置宽高：width=&quot;400px&quot; height=&quot;300px&quot;

在页面加载完成后调用：    &lt;body onload=&quot;init()&quot;&gt;


引入three.js文件</code></pre>
<p>​<br>​    在script标签中，定义init()函数：<br>​<br>    //渲染器WebGLRenderer<br>    var renderer= new THREE.WebGLRenderer({</p>
<pre><code>//创建场景
var scene= new THREE.Scene();

//创建照相机，并添加到场景中
var camera = new THREE.PerspectiveCamera(45, 4 / 3, 1, 1000); 

//创建长方体，设置为红色，并添加到场景中
var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 2, 3), 

//渲染
renderer.render(scene, camera); </code></pre>
<p>完整代码如下：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;script src=&quot;three.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
            function init()&#123;
                //渲染器WebGLRenderer
                var renderer= new THREE.WebGLRenderer(&#123;
                    canvas: document.getElementById(&#39;mainCanvas&#39;)
                    //指定id的canvas标签
                &#125;)
                renderer.setClearColor(0x000000); 

                //创建场景
                var scene= new THREE.Scene();

                //创建照相机，并添加到场景中
                var camera = new THREE.PerspectiveCamera(45, 4 / 3, 1, 1000); 
                camera.position.set(0, 0, 5); 
                scene.add(camera); 

                //创建长方体，设置为红色
                var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 2, 3), 
            new THREE.MeshBasicMaterial(&#123; 
                color: 0xff0000 
                &#125;) 
                ); 
                scene.add(cube); 

                //渲染
                renderer.render(scene, camera); 
            &#125;
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body onload=&quot;init()&quot;&gt;
        &lt;!--页面加载后执行init函数--&gt;

        &lt;canvas id=&quot;mainCanvas&quot; width=&quot;400px&quot; height=&quot;300px&quot;&gt;&lt;/canvas&gt;

    &lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="实例2："><a href="#实例2：" class="headerlink" title="实例2："></a>实例2：</h2><p>预览图：</p>
<p><img src="http://wx3.sinaimg.cn/mw690/e42e0766gy1fddmkw1pvrj20b408c747.jpg"></p>
<p>设置照相机的位置：</p>
<pre><code>camera.position.set(4, 3, 5); //设置照相机的位置
camera.lookAt(new THREE.Vector3(0, 0, 0)); </code></pre>
<p>示意图：</p>
<p><img src="http://wx1.sinaimg.cn/mw690/e42e0766gy1fddmxmbv4qj20qd0hzq35.jpg"></p>
<p>完整代码如下：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;script src=&quot;three.js&quot;&gt;&lt;/script&gt;
        &lt;script&gt;
            //正交投影照相机（Orthographic Camera）
            //

            function init()&#123;
                //渲染器WebGLRenderer
                var renderer= new THREE.WebGLRenderer(&#123;
                    canvas: document.getElementById(&#39;mainCanvas&#39;)
                    //指定id的canvas标签
                &#125;)
                renderer.setClearColor(0x000000); 

                //创建场景
                var scene= new THREE.Scene();

                //创建照相机，并添加到场景中
                var camera = new THREE.OrthographicCamera(-2, 2, 1.5, -1.5, 1, 10);
                camera.position.set(4, 3, 5); //设置照相机的位置，在此位置上有新视角！
                camera.lookAt(new THREE.Vector3(0, 0, 0)); //设置照相机向着原点而非z轴负方向。
                scene.add(camera); 

                //创建长方体，设置为红色
                var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 3), 
                    new THREE.MeshBasicMaterial(&#123; 
                        color: 0xff0000,
                        wireframe:true
                    &#125;) 
                ); 
                scene.add(cube); 

                //渲染
                renderer.render(scene, camera); 
            &#125;
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body onload=&quot;init()&quot;&gt;
        &lt;!--页面加载后执行init函数--&gt;

        &lt;canvas id=&quot;mainCanvas&quot; width=&quot;400px&quot; height=&quot;300px&quot;&gt;&lt;/canvas&gt;

    &lt;!--WebGL No.1 - Three.js 入门--&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>1</p>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
        <tag>ThreeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>Github+Yelee搭建博客过程</title>
    <url>/posts/6af0570c/</url>
    <content><![CDATA[<h2 id="intro">前言</h2>本篇文章记录了自己在学习用 <b>Github+Yelee</b> 搭建博客的过程中的各种尝试和思考。
<a id="more"></a>

<p>周一（20170213）早上开始在Github上搭建博客。前后花了将近一天的时间，充分了解了博客搭建的原理、步骤，最后动手进行实践。</p>
<p>第二天继续探索新文章的书写和发布相关的内容，以及标签云、文章分类、文章添加标签、文章置顶显示等方法。</p>
<p>一、博客的搭建过程</p>
<blockquote>
<p>搭建环境准备（包括Node.js和Git环境，GitHub账户的配置）</p>
<p>安装Hexo</p>
<p>配置Hexo</p>
<p>将Hexo与github page 联系起来</p>
<p><strong>一些坑与注意事项</strong></p>
</blockquote>
<p>二、继续探索与完善</p>
<blockquote>
<p>添加 404 公益页面</p>
<p>主题的简单配置</p>
<p>主题推荐</p>
<p>添加插件</p>
</blockquote>
<h1 id="一、博客的搭建过程"><a href="#一、博客的搭建过程" class="headerlink" title="一、博客的搭建过程"></a>一、博客的搭建过程</h1><h2 id="搭建环境准备"><a href="#搭建环境准备" class="headerlink" title="搭建环境准备"></a>搭建环境准备</h2><h3 id="Node-js-环境"><a href="#Node-js-环境" class="headerlink" title="Node.js 环境"></a>Node.js 环境</h3><p>这里我安装的是 node-v5.10.1-x64.msi，要根据实际情况选择32位或64位版本。</p>
<p><a href="https://nodejs.org/dist/">下载 Node.js安装文件</a></p>
<p>可以将安装目录改到D盘，其余默认安装就行。</p>
<p>安装完成后，同时按住键盘上的Win 和 R</p>
<p><img src="https://raw.githubusercontent.com/gittig11/Markdown-Pics/master/Github%20Pages%20Setup/Win%2BR.jpg" alt="Win和R"></p>
<p>打开运行窗口，输入：</p>
<blockquote>
<p>$ node -v</p>
<p>$ npm -v</p>
</blockquote>
<p>能查到版本号则说明安装成功。</p>
<h3 id="Git-环境"><a href="#Git-环境" class="headerlink" title="Git 环境"></a>Git 环境</h3><p><a href="https://git-scm.com/">下载 Git安装文件 官网地址</a></p>
<p>Git的安装界面</p>
<p><img src="https://raw.githubusercontent.com/gittig11/Markdown-Pics/master/Github%20Pages%20Setup/Git%E7%9A%84%E5%AE%89%E8%A3%85%E7%95%8C%E9%9D%A2.jpg" alt="Git的安装界面.jpg"></p>
<p>Git PATH设置</p>
<p><img src="https://raw.githubusercontent.com/gittig11/Markdown-Pics/master/Github%20Pages%20Setup/Git%20PATH%E8%AE%BE%E7%BD%AE.jpg" alt="Git PATH设置.jpg"></p>
<p>可以将安装目录改到D盘，其余默认安装就行。<br>安装完成后，打开命令行，输入：</p>
<blockquote>
<p>git - -version</p>
</blockquote>
<p>查看安装的版本号。</p>
<h3 id="Github账户的注册和配置"><a href="#Github账户的注册和配置" class="headerlink" title="Github账户的注册和配置"></a>Github账户的注册和配置</h3><p>打开 <a href="https://github.com/">https://github.com/</a>，在下图的框中，分别输入自己的用户名，邮箱，密码。<br>查看邮箱，对于收到的确认邮件<b>点击确认注册的链接</b>，即注册成功！</p>
<p>接下来是Github配置。</p>
<p>1、创建仓库</p>
<p><img src="https://github.com/gittig11/Markdown-Pics/blob/master/Github%20Pages%20Setup/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.jpg?raw=true" alt="创建仓库.jpg"></p>
<p>填写仓库名，仓库名与Owner名称保持一致，<br>比如我填写的是：<b>gittig11.github.io</b></p>
<p><img src="https://github.com/gittig11/Markdown-Pics/blob/master/Github%20Pages%20Setup/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93-%E4%BB%93%E5%BA%93%E5%90%8D.png?raw=true" alt="创建仓库-仓库名.png"><br>点击界面右侧的Settings，向下拖动，直到看见GitHub Pages。source 选择的是 <b>master branch</b><br><img src="https://github.com/gittig11/Markdown-Pics/blob/master/Github%20Pages%20Setup/GitHub%20Pages.png?raw=true" alt="GitHub Pages.png"><br>点击save保存。</p>
<p>这样 Github 的配置就告一段落了。</p>
<h2 id="安装和配置-Hexo"><a href="#安装和配置-Hexo" class="headerlink" title="安装和配置 Hexo"></a>安装和配置 Hexo</h2><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>可以选择E盘，新建“Hexo”文件夹，<br>在该文件夹中，右键选择</p>
<p><img src="https://github.com/gittig11/Markdown-Pics/blob/master/Github%20Pages%20Setup/git%E5%8F%B3%E9%94%AE%E9%80%89%E6%8B%A9.png?raw=true" alt="git右键选择"></p>
<p>接着输入命令：</p>
<pre><code>$ npm install hexo-cli -g
$ npm install hexo --save
$ hexo -v</code></pre>
<p>查看到下列信息说明安装成功了。</p>
<pre><code>hexo-cli: 1.0.2
os: Windows_NT 6.1.7601 win32 x64
http_parser: 2.6.2
node: 5.10.1
v8: 4.6.85.31
uv: 1.8.0
zlib: 1.2.8
ares: 1.10.1-DEV
icu: 56.1
modules: 47
openssl: 1.0.2g</code></pre>
<h3 id="Hexo的相关配置"><a href="#Hexo的相关配置" class="headerlink" title="Hexo的相关配置"></a>Hexo的相关配置</h3><p>初始化Hexo</p>
<blockquote>
<p>$ hexo init</p>
</blockquote>
<p>然后输入：</p>
<blockquote>
<p>$ npm install</p>
</blockquote>
<p>之后 npm 会自动安装你需要的组件，等待npm操作完成即可。</p>
<h3 id="首次体验-Hexo"><a href="#首次体验-Hexo" class="headerlink" title="首次体验 Hexo"></a>首次体验 Hexo</h3><p>继续之前的操作，同样是在命令行中，</p>
<p><strong>生成静态页面</strong></p>
<blockquote>
<p>$ hexo g</p>
</blockquote>
<p><strong>运行本地服务器</strong></p>
<blockquote>
<p>$ hexo s</p>
</blockquote>
<p>然后会提示：INFO Hexo is running at <a href="http://localhost:4000/">http://localhost:4000/</a>. Press Ctrl+C to stop.</p>
<p>在浏览器中打开 <a href="http://localhost:4000/">http://localhost:4000/</a>，你将会看到：</p>
<p><img src="https://github.com/gittig11/Markdown-Pics/blob/master/Github%20Pages%20Setup/localhost.jpg?raw=true" alt="localhost"></p>
<p>说明Hexo搭建成功了！</p>
<h3 id="将-Hexo-与-Github-pages-联系起来"><a href="#将-Hexo-与-Github-pages-联系起来" class="headerlink" title="将 Hexo 与 Github pages 联系起来"></a>将 Hexo 与 Github pages 联系起来</h3><p><strong>1、配置Git个人信息</strong></p>
<blockquote>
<p>$ git config –global user.name “gittig11”</p>
<p>$ git config –global user.email “<a href="mailto:&#103;&#105;&#x74;&#116;&#x69;&#x67;&#49;&#49;&#64;&#x31;&#54;&#51;&#46;&#99;&#111;&#x6d;">&#103;&#105;&#x74;&#116;&#x69;&#x67;&#49;&#49;&#64;&#x31;&#54;&#51;&#46;&#99;&#111;&#x6d;</a>“</p>
</blockquote>
<p><strong>2、生成密钥</strong></p>
<blockquote>
<p>$ ssh-keygen -t rsa -C “<a href="mailto:&#103;&#105;&#116;&#116;&#105;&#103;&#49;&#49;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#109;">&#103;&#105;&#116;&#116;&#105;&#103;&#49;&#49;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#109;</a>“</p>
</blockquote>
<p><strong>3、粘贴密钥到 Github 上</strong></p>
<p>第3步会在目录“C:\Users\Administrator.ssh”中生成两个文件：id_rsa 和 id_rsa.pub，</p>
<p>复制公钥信息并粘贴在 Github 的ssh密钥管理页面。</p>
<p><img src="https://github.com/gittig11/Markdown-Pics/blob/master/Github%20Pages%20Setup/profile.png?raw=true" alt="profile"></p>
<p><strong>4、SSH认证</strong></p>
<blockquote>
<p>$  ssh -T <a href="mailto:&#x67;&#105;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;">&#x67;&#105;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;</a></p>
</blockquote>
<p>提示：</p>
<pre><code>Hi gittig11! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre>
<p>则表明成功了！</p>
<p><strong>5、配置 Deployment</strong></p>
<p>同样在_config.yml文件中，找到Deployment，然后按照如下修改：</p>
<pre><code>deploy:
type: git
@github.com:yourname/yourname.github.io.git
branch: master</code></pre>
<p>参考配置如下:</p>
<pre><code>deploy:
  type: git
  @github.com:gittig11/gittig11.github.io.git
  branch: master</code></pre>
<h3 id="写博客、发布文章"><a href="#写博客、发布文章" class="headerlink" title="写博客、发布文章"></a>写博客、发布文章</h3><p>新建一篇博客，在“E:\Hexo”目录中，右键打开 Git bash,</p>
<blockquote>
<p>$ hexo new post “title”</p>
</blockquote>
<p>这时候在我的 电脑的目录下 E:\hexo\source_posts 将会看到 title.md 文件<br>用MarDown编辑器打开就可以编辑文章了。</p>
<p>文章编辑好之后，运行生成、部署命令：</p>
<blockquote>
<p>$ hexo g   // 生成</p>
<p>$ hexo d   // 部署</p>
</blockquote>
<p> 当然你也可以执行下面的命令，相当于上面两条命令的效果</p>
<blockquote>
<p>$ hexo d -g<br>//在部署前先生成</p>
</blockquote>
<p>部署成功后，访问你的地址 yourName.github.io（这里我的地址： <a href="https://gittig11.github.io/">https://gittig11.github.io</a>)，将可以看到生成的文章。</p>
<h2 id="一些坑与注意事项"><a href="#一些坑与注意事项" class="headerlink" title="一些坑与注意事项"></a>一些坑与注意事项</h2><p><strong>1、hexo d 碰到“Deployer not found”?</strong></p>
<p>需要修改_config.yml 配置文件，将deploy下的“type”字段中的“github”改为“git”。<br>再执行 </p>
<blockquote>
<p>npm install hexo-deployer-git –save</p>
</blockquote>
<p><strong>2、执行命令 $ ssh -T <a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#109;">&#103;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#109;</a> 时提示</strong></p>
<pre><code>Warning: Permanently added the RSA host key for IP address &#39;192.30.253.113&#39; to the list of known hosts.
Permission denied (publickey).</code></pre>
<p>原因：没有在Github上粘贴公钥。</p>
<h1 id="二、继续探索与完善"><a href="#二、继续探索与完善" class="headerlink" title="二、继续探索与完善"></a>二、继续探索与完善</h1><pre><code>……
……</code></pre>
]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
</search>
